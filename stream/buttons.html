<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Control</title>
<link rel="stylesheet" href="/shared.css" />
<style>
    html, body {
        margin: 0;
        height: 100%;
        width: 100%;
        background: #111;
    }

    .grid {
        height: 100%;
        width: 100%;
        display: grid;
        grid-template-rows: 1fr 1fr 1fr;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 4px;
        background: #000;
    }

    .btn {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
        color: #fff;
        font-size: clamp(1.2rem, 4.5vw, 2.2rem); /* scale with parent/viewport so mobile fullscreen stays reasonable */
        user-select: none;
        cursor: pointer;
        border-radius: 0;
        /* no hover, no active states */
    }
    /* Minimal inline text box (mirrors player page) */
    #shoutComposer {
        position: fixed;
        top: 45%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(440px, 92vw);
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 10px;
        padding: 8px 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 6px;
        z-index: 12;
    }
    #shoutComposer.hidden {
        display: none;
    }
    #shoutInput {
        flex: 1;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 8px;
        color: white;
        padding: 8px 10px;
        font-size: 16px;
        outline: none;
        min-width: 0;
    }
    #shoutInput:focus {
        border-color: rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.14);
    }
</style>
</head>

<body>

<div class="grid">
    <div class="btn fs-btn" onclick="toggleFullscreen()">FULL</div>
    <div class="btn" onclick="send('/up')">UP</div>
    <div class="btn" onclick="openShoutComposer()">TEXT</div>

    <div class="btn" onclick="send('/left')">LEFT</div>
    <div class="btn" onclick="send('/space')">SPACE</div>
    <div class="btn" onclick="send('/right')">RIGHT</div>

    <div></div>
    <div class="btn" onclick="send('/down')">DOWN</div>
    <div></div>
</div>

<div id="shoutComposer" class="hidden">
    <input
        id="shoutInput"
        type="text"
    />
    <div id="soundPopup" class="sound-popup hidden"></div>
</div>

<script>
async function send(path) {
    try { await fetch(path, { method: "POST" }); }
    catch (e) { console.error(e); }
}

const shoutComposer = document.getElementById("shoutComposer");
const shoutInput = document.getElementById("shoutInput");
const soundPopup = document.getElementById("soundPopup");
let shoutOpen = false;
let soundList = null;
let filteredSounds = [];
let selectedSoundIndex = -1;

// Keep page focused so key events always land here, even after taps/clicks
document.body.setAttribute("tabindex", "-1");
document.body.focus();
window.addEventListener("pointerup", () => setTimeout(() => document.body.focus(), 0));
window.addEventListener("focus", () => document.body.focus());

function openShoutComposer() {
    shoutOpen = true;
    shoutInput.value = "";
    shoutComposer.classList.remove("hidden");
    setTimeout(() => shoutInput.focus(), 0);
}

function closeShoutComposer() {
    shoutOpen = false;
    shoutComposer.classList.add("hidden");
    soundPopup.classList.add("hidden");
    shoutInput.blur();
}

async function submitShout() {
    const message = shoutInput.value.trim();
    if (!message) {
        closeShoutComposer();
        return;
    }
    try {
        await fetch("/shout", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message }),
        });
    } catch (e) {
        console.error("shout failed", e);
    }
    closeShoutComposer();
}

async function loadSoundList() {
    if (soundList) return soundList;
    try {
        const res = await fetch("/soundlist");
        if (!res.ok) return [];
        const data = await res.json();
        soundList = Array.isArray(data.sounds) ? data.sounds : [];
    } catch (_) {
        soundList = [];
    }
    return soundList;
}

function renderSoundPopup(items) {
    filteredSounds = items;
    if (!items.length) {
        soundPopup.classList.add("hidden");
        soundPopup.replaceChildren();
        selectedSoundIndex = -1;
        return;
    }
    selectedSoundIndex = Math.min(Math.max(selectedSoundIndex, 0), items.length - 1);
    const fragment = document.createDocumentFragment();
    for (let idx = 0; idx < items.length; idx += 1) {
        const name = items[idx];
        const item = document.createElement("div");
        item.className = "sound-item" + (idx === selectedSoundIndex ? " selected" : "");
        item.dataset.name = name;
        item.textContent = name;
        fragment.appendChild(item);
    }
    soundPopup.replaceChildren(fragment);
    soundPopup.classList.remove("hidden");
}

async function updateSoundPopup() {
    const value = shoutInput.value.trim();
    if (!value.startsWith("#")) {
        soundPopup.classList.add("hidden");
        return;
    }
    const all = await loadSoundList();
    if (value === "#" || value === "# ") {
        selectedSoundIndex = 0;
        renderSoundPopup(all);
        return;
    }
    const needle = value.slice(1).toLowerCase();
    const filtered = all.filter((name) => name.toLowerCase().startsWith(needle));
    selectedSoundIndex = 0;
    renderSoundPopup(filtered);
}

function selectFirstSound() {
    if (!filteredSounds.length) return false;
    const name = filteredSounds[Math.max(selectedSoundIndex, 0)];
    shoutInput.value = `#${name}`;
    return true;
}

function moveSoundSelection(delta) {
    if (!filteredSounds.length) return;
    selectedSoundIndex = (selectedSoundIndex + delta + filteredSounds.length) % filteredSounds.length;
    renderSoundPopup(filteredSounds);
    const selected = soundPopup.querySelector(".sound-item.selected");
    if (selected) {
        selected.scrollIntoView({ block: "nearest" });
    }
}

shoutInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
        e.preventDefault();
        if (shoutInput.value.trim().startsWith("#")) {
            selectFirstSound();
        }
        submitShout();
    } else if (e.key === "Escape") {
        e.preventDefault();
        closeShoutComposer();
    } else if (e.key === "ArrowDown") {
        e.preventDefault();
        if (shoutInput.value.trim().startsWith("#")) {
            moveSoundSelection(1);
        }
    } else if (e.key === "ArrowUp") {
        e.preventDefault();
        if (shoutInput.value.trim().startsWith("#")) {
            moveSoundSelection(-1);
        }
    } else if (e.key === "Tab") {
        e.preventDefault();
        if (shoutInput.value.trim().startsWith("#")) {
            moveSoundSelection(e.shiftKey ? -1 : 1);
        }
    }
});

shoutInput.addEventListener("input", () => {
    updateSoundPopup();
});

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
        setTimeout(() => window.scrollTo(0, 0), 0);
    } else {
        document.exitFullscreen().catch(() => {});
    }
}

document.addEventListener("fullscreenchange", () => {
    // Keep FULL button visible so it can be used to exit fullscreen
});

// Mirror the main player keyboard controls here too
window.addEventListener("keydown", (e) => {
    if (shoutOpen) return; // input handles its own keys

    if (e.key === "Enter") {
        e.preventDefault();
        openShoutComposer();
        return;
    }
    if (e.key === "#") {
        e.preventDefault();
        openShoutComposer();
        shoutInput.value = "#";
        updateSoundPopup();
        return;
    }

    let path = null;
    switch (e.key) {
        case " ":
        case "Spacebar":
            path = "/space";
            break;
        case "ArrowLeft":
            path = "/left";
            break;
        case "ArrowRight":
            path = "/right";
            break;
        case "ArrowUp":
            path = "/up";
            break;
        case "ArrowDown":
            path = "/down";
            break;
    }

    if (!path) return;

    e.preventDefault();
    send(path);
});
</script>

</body>
</html>
