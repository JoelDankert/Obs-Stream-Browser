
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Live Stream</title>
    <style>
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
      }


#container {
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
  position: relative;
  overflow: hidden;
}

/* Video frame */
#player {
  border: 0;
  background: #000;
  width: min(100vw, calc(100vh * 16 / 9));
  height: min(100vh, calc(100vw * 9 / 16));
}

/* Fullscreen button stays on top */
#fsBtn {
  position: absolute;
  left: 20px;
  top: 20px;
  width: 55px;
  height: 55px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: 0.15s, opacity 0.3s ease;
  z-index: 10;
}
      #fsBtn:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      #fsBtn svg {
        width: 55%;
        height: 55%;
        fill: white;
      }
      /* Hidden in fullscreen */
      .fullscreen-hide {
        opacity: 0;
        pointer-events: none;
      }

      /* Shout composer */
      #shoutComposer {
        position: absolute;
        top: 45%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(420px, 90vw);
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 12px;
        padding: 8px 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
        z-index: 12;
      }
      #shoutComposer.hidden {
        display: none;
      }
      #shoutInput {
        width: 95%;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 8px;
        color: white;
        padding: 8px 10px;
        font-size: 16px;
        outline: none;
      }
      #shoutInput:focus {
        border-color: rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.14);
      }
    </style>
  </head>
  <body tabindex="-1">
    <div id="container">
      <!-- MediaMTX WebRTC player (native video) -->
      <video
        id="player"
        autoplay
        playsinline
        controls
        muted
      ></video>

      <!-- Fullscreen button -->
      <div id="fsBtn" title="Fullscreen">
        <svg viewBox="0 0 23 23">
          <path
            d="M12.5 7C12.5 6.58579 12.8358 6.25 13.25 6.25H17C17.4142 6.25 17.75 6.58579 17.75 7V10.75C17.75 11.1642 17.4142 11.5 17 11.5C16.5858 11.5 16.25 11.1642 16.25 10.75V8.81066L8.81066 16.25H10.75C11.1642 16.25 11.5 16.5858 11.5 17C11.5 17.4142 11.1642 17.75 10.75 17.75H7C6.58579 17.75 6.25 17.4142 6.25 17V13.25C6.25 12.8358 6.58579 12.5 7 12.5C7.41421 12.5 7.75 12.8358 7.75 13.25V15.1893L15.1893 7.75H13.25C12.8358 7.75 12.5 7.41421 12.5 7Z"
          />
        </svg>
      </div>

      <!-- Shout composer (Enter to open, Enter to send) -->
      <div id="shoutComposer" class="hidden">
        <input
          id="shoutInput"
          type="text"
          maxlength="140"
          autocomplete="off"
          placeholder="meme overlay (TOP TEXT/BOTTOM TEXT)"
        />
      </div>
    </div>

    <script>
      const fsBtn = document.getElementById("fsBtn");
      const container = document.getElementById("container");
      const body = document.body;
      const player = document.getElementById("player");
      const shoutComposer = document.getElementById("shoutComposer");
      const shoutInput = document.getElementById("shoutInput");
      let shoutOpen = false;

      // ------- WEBRTC (WHEP) PLAYBACK -------

      const PATH_NAME = "stream";
      const MEDIA_BASE = `${window.location.protocol}//${window.location.hostname}:8889`;
      const WEBRTC_PATHS = [
        `/${PATH_NAME}/whep`, // WHEP (newer)
        `/whep/${PATH_NAME}`, // alternate layout
        `/${PATH_NAME}`, // legacy JSON/SDP endpoint
      ];
      let pc;

      async function waitForIceGatheringComplete(connection) {
        if (connection.iceGatheringState === "complete") return;
        await new Promise((resolve) => {
          const checkState = () => {
            if (connection.iceGatheringState === "complete") {
              connection.removeEventListener("icegatheringstatechange", checkState);
              resolve();
            }
          };
          connection.addEventListener("icegatheringstatechange", checkState);
        });
      }

      async function fetchAnswer(sdp) {
        for (const path of WEBRTC_PATHS) {
          const url = `${MEDIA_BASE}${path}`;
          try {
            const res = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/sdp" },
              body: sdp,
            });
            if (res.ok) {
              return res.text();
            }
          } catch (_) {
            /* try next path */
          }
        }
        throw new Error("All WebRTC endpoints failed");
      }

      async function startPlayback() {
        pc = new RTCPeerConnection();
        pc.addTransceiver("video", { direction: "recvonly" });
        pc.addTransceiver("audio", { direction: "recvonly" });

        pc.addEventListener("track", (event) => {
          if (event.streams && event.streams[0]) {
            player.srcObject = event.streams[0];
            player.play().catch(() => {});
          }
        });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForIceGatheringComplete(pc);

        const answer = await fetchAnswer(pc.localDescription.sdp);
        await pc.setRemoteDescription(new RTCSessionDescription({ type: "answer", sdp: answer }));
      }

      startPlayback().catch((err) => {
        console.error("WebRTC playback failed", err);
      });

      // Keep page focused so key events stay here even after interacting with the player UI
      body.focus();
      player.setAttribute("tabindex", "-1");
      player.addEventListener("pointerup", () => setTimeout(() => body.focus(), 0));
      window.addEventListener("focus", () => body.focus());
      window.addEventListener("blur", () => {
        if (document.activeElement === player) {
          setTimeout(() => body.focus(), 0);
        }
      });

      window.addEventListener("beforeunload", () => {
        if (pc) {
          pc.close();
        }
      });

      // ------- SHOUT / OVERLAY MESSAGE -------

      function openShoutComposer() {
        shoutOpen = true;
        shoutInput.value = "";
        shoutComposer.classList.remove("hidden");
        setTimeout(() => shoutInput.focus(), 0);
      }

      function closeShoutComposer() {
        shoutOpen = false;
        shoutComposer.classList.add("hidden");
        shoutInput.blur();
        body.focus();
      }

      async function submitShout() {
        const message = shoutInput.value.trim();
        if (!message) {
          closeShoutComposer();
          return;
        }
        try {
          await fetch("/shout", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message }),
          });
        } catch (err) {
          console.warn("Shout send failed", err);
        }
        closeShoutComposer();
      }

      // ------- INPUT HANDLING (same behavior as before) -------

      async function sendInput(endpoint) {
        try {
          await fetch(endpoint, { method: "POST" });
        } catch (err) {
          console.warn(`Input error for ${endpoint}:`, err);
        }
      }


      // Keyboard handling on window
      window.addEventListener("keydown", (e) => {
        if (shoutOpen) {
          if (e.key === "Escape") {
            e.preventDefault();
            closeShoutComposer();
            return;
          }
          if (e.key === "Enter") {
            e.preventDefault();
            submitShout();
            return;
          }
          return; // allow typing inside the input
        }

        if (e.key === "Enter") {
          e.preventDefault();
          openShoutComposer();
          return;
        }

        let endpoint = null;

        switch (e.key) {
          case " ":
          case "Spacebar":
            endpoint = "/space";
            break;
          case "ArrowLeft":
            endpoint = "/left";
            break;
          case "ArrowRight":
            endpoint = "/right";
            break;
          case "ArrowUp":
            endpoint = "/up";
            break;
          case "ArrowDown":
            endpoint = "/down";
            break;
        }

        if (!endpoint) return;

        e.preventDefault();
        sendInput(endpoint);
      });

      // ------- FULLSCREEN HANDLING -------

      fsBtn.addEventListener("click", () => {
        if (!document.fullscreenElement) {
          container.requestFullscreen().catch(() => {});
        } else {
          document.exitFullscreen().catch(() => {});
        }
      });

      document.addEventListener("fullscreenchange", () => {
        if (document.fullscreenElement) {
          fsBtn.classList.add("fullscreen-hide");
        } else {
          fsBtn.classList.remove("fullscreen-hide");
        }
      });
    </script>
  </body>
</html>
